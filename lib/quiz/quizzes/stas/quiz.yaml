theme: Душный квиз по Flutter
level: 3
questions:
  - question: "Является ли Dart null-безопасным языком?"
    picture: ""
    options: ["Нет","Да","Частично"]
    correct_option_id: 1
    explanation: "Начиная с марта 2021 и Dart 2.12 соответсвенно, в Dart появилась Sound Null Safety. Ох сколько боли и слез было у тех людей, кому приходилось переписывать старые проекты..."
    open_period: 20
  - question: "Интерфейсом для реализации какого паттерна проектирования является абстрактный класс Listner?"
    picture: ""
    options: ["Фабрика","Стратегия","Наблюдатель","Посетитель"]
    correct_option_id: 2
    explanation: "Это база"
    open_period: 20
  - question: "Как называется сборщик мусора молодого поколения в Dart?"
    picture: ""
    options: ["Scraper","Sweeper","Scavenger","Janitor"]
    correct_option_id: 2
    explanation: "Scavenger - названия сборщиков молодого мусора в Dart VM и движке V8 для JS, хоть и работают они немного по разному"
    open_period: 20
  - question: "Когда в языке Dart объект считается 'мертвым' и подлежит удалению из памяти?"
    picture: ""
    options: ["Когда счетчик 'сильных' ссылок становится равным нулю","Когда от корневого объекта на данный объект больше не существует пути по ссылке", "Когда до ноды объекта в графе зависисмотей больше не существует пути"]
    correct_option_id: 1
    explanation: "Второе верно. Более подробно можно прочитать тут: https://medium.com/flutter/flutter-dont-fear-the-garbage-collector-d69b3ff1ca30"
    open_period: 20
  - question: "Сколько поколений имеет Garbage Collector Dart VM?"
    picture: ""
    options: ["1", "2", "3", "4"]
    correct_option_id: 1
    explanation: "Два поколения: в первом уничтожается короткоживущие объекты - мусор 'молодого' поколения, во втором 'старого' - объекты пережившие цикл сборки мусора."
    open_period: 20
  - question: "Что происходит при создании объекта Future?"
    picture: ""
    options: ["Создается Timer", "Открывается изолят в который передается callback", "Планируется событие с Future через WidgetsBinding.instance.addPostFrameCallback"]
    correct_option_id: 0
    explanation: "В конструкторе вызывается Timer с переданным Duration, если был использован конструктор Future.delayed в иныч случаях вызывает Timer.run()"
    open_period: 20
  - question: "Какая структура данных используется для добавления в очередь таймеров с Duration > 0?"
    picture: ""
    options: ["HashSet","HashMap", "Двоичная куча", "Односвязный список"]
    correct_option_id: 2
    explanation: "Таймеры с Duration равным 0 попадают в односвязный список, с ненулевой продолжительностью в двоичную кучу"
    open_period: 20
  - question: "Как обрабатываются таймеры с ненулевой задержкой?"
    picture: ""
    options: ["Фреймворк считает 'тики', поставляемые SchedulerBinding", "С помощью системного будильника в EventHandler Thread", "Зарегестрированные в куче будильники крутятся в бесконечном цикле с проверкой на истечение времени"]
    correct_option_id: 1
    explanation: "Второе верно, но для тех кому интересно советую прочитать https://habr.com/ru/companies/ligastavok/articles/539782/, там максимально подробно описан процесс работы Future и таймеров"
    open_period: 20
  - question: "Какие два сообщения выведутся последними?"
    picture: "https://i.ibb.co/w6Mp1T5/2024-02-25-20-33-46.png"
    options: ["Fifth и Ended","Second и Third","Third и Ended","Fifth и Fourth","Third и Fifth"]
    correct_option_id: 3
    explanation: "await говорит о том, что необходимо дождаться результата выполнения Future прежде чем перейти к следующей строчке. Future.microtask же имеют более высокий приоритет в Цикле Событий"
    open_period: 20
  - question: "Нужна ли виртуальная машина Dart для собранного в AOT режиме приложения?"
    picture: ""
    options: ["Нужна","Не нужна", "Зависит от ситуации, VM может динамически подключаться"]
    correct_option_id: 0
    explanation: "Да, нужна. Как без нее все вещи из вопросов выше работать будут?)"
    open_period: 20
  - question: "Что делает метод runApp?"
    picture: "https://i.ibb.co/r2fpkr9/2024-02-25-20-55-59.png"
    options: ["Устанавливает связь с Flutter Engine, инициализируя биндинги", "Добавляет в дерево Корневой Виджет и Элемент, а также переданный аргументом виджет","Запускает процесс сборки и отрисовки", "Планирует отрисовку первого фрейма как можно быстрее", "Все вышеперечисленное"]
    correct_option_id: 4
    explanation: "Все утверждения верны. Подробнее тут: https://api.flutter.dev/flutter/widgets/runApp.html."
    open_period: 20
  - question: "Тип компонентов, отвечающих за управление состоянием и жизненным циклом виджетов (и не только) во Flutter"
    picture: ""
    options: ["Element", "Widget", "Render Object", "Semantics", "Diagnosticable"]
    correct_option_id: 0
    explanation: "Element. Создается при помощи вызова createElement у любого виджета, ссылается на RenderObject. Как и было сказано управляет жизненным циклом виджетов и рендер объектов."
    open_period: 20
  - question: "Как фреймворк понимает, что данный участок дерева нуждается в перерисовке?"
    picture: ""
    options: ["setState вызывает функцию билд и состояния виджетов автоматически обновляются", "Корневой элемент по подписке уведомляется о том, что состояние одного из потомков изменилось","Элемент в дереве помечается как dirty, и передается в список _dirtyElements у BuildOwner"]
    correct_option_id: 2
    explanation: "Третье) https://habr.com/ru/articles/501862/ - первая из цикла статей Михаила Зотьева 'Flutter под капотом'"
    open_period: 20
  - question: "Что произойдет если внутри функции build вызывать метод setState?"
    picture: "https://i.ibb.co/Rb4R4rY/2024-02-26-19-27-48.png"
    options: ["Ничего, приложение продолжит работать. Ошибок не будет.", "Упадет предупреждение в логах, приложение продолжит работать.", "Произойдет бесконечный цикл перерисовки. Приложение крашнется.", "Произойдет утечка памяти. Приложение крашнется"]
    correct_option_id: 0
    explanation: "Приложение продолжит работать и не возникнет бесконечного цикла, так как при вызове markNeedsRebuld, вызываемой setState происходит проверка, является ли элемент dirty"
    open_period: 20
  - question: "Может ли неактивный элемент быть встроен заново в дерево?"
    picture: ""
    options: ["Нет, он будет удален из памяти при следующем запуске цикла сборки мусора", "Да, он снова появится в дереве как только у его виджета будет вызван setState","Да, может снова появится в дереве если у него или у его родительского элемента есть глобальный ключ"]
    correct_option_id: 2
    explanation: "Да, может, если у него или у его родительского элемента есть глобальный ключ, но важно, что это должно произойти только в течение текущего фрейма"
    open_period: 20
  - question: "Есть ли во Flutter возможность подписаться на изменения виджета, находящегося выше по дереву?"
    picture: ""
    options: ["Нет, только использовать StreamBuilder","Да, подписаться на InheritedWidget", "Да, использовать ChangeNotifier"]
    correct_option_id: 1
    explanation: "Это база, используем Inherited Widget"
    open_period: 20
  - question: "Как можно 'достучаться' из Flutter приложения до нативного функционала платформы?"
    picture: ""
    options: ["Создать канал платформы на стороне Flutter приложения и плагинов", "Написать FFI интерфейс", "Запустить изолят между Flutter приложением и платформой", "Никак"]
    correct_option_id: 0
    explanation: "Для этих целей создан механизм каналов платформы, чаще всего можно и нужно использовать именно MethodChannel. Статейка про это https://habr.com/ru/articles/666272/"
    open_period: 20
  - question: "Как называется новый движок во Flutter?"
    picture: ""
    options: [ "Skia","Skiko","Impeller", "Implier"]
    correct_option_id: 2
    explanation: "Impeller. Implier - это вообще локальный мем. У нас в компании половина разрабов почему-то называла импеллер имплаером)))"
    open_period: 20
  - question: "Какую проблему призван решить Impeller"
    picture: ""
    options: ["Проблема прекомпиляции шейдеров и поддержки современных графических API", "Как таковой проблемы не было, команда Flutter хотела отгородиться от стороннего графического движка", "Проблему обрыва биндингов между движком и Dart рантаймом из-за чего происходили неожиданные краши"]
    correct_option_id: 0
    explanation: "Первый. При старте приложения могли подтормаживать анимации, особенно на iOS, а также Skia просто устарела и не поддерживала ни Vulcan, ни Metal (что было опять таки особенно больно на iOS)"
    open_period: 20
  - question: "Какого типа виджетов НЕ существует во Flutter?"
    picture: ""
    options: ["Stateless Widget", "Inherited Widget", "Stateful Widget", "Semantics", "Все существуют"]
    correct_option_id: 4
    explanation: "База, существуют все"
    open_period: 20
  - question: "Название протокола расчета макета для НЕ СКРОЛЯЩИХСЯ рендер объектов во Flutter"
    picture: ""
    options: ["Basic Protocol", "Bundle Protocol", "Box Protocol", "Render Protocol"]
    correct_option_id: 2
    explanation: "Box Protocol. Подробнее тут: https://api.flutter.dev/flutter/rendering/RenderBox-class.html"
    open_period: 20
  - question: "Название протокола расчета макета для СКРОЛЯЩИХСЯ рендер объектов во Flutter"
    picture: ""
    options: ["Sliver Protocol","Slider Protocol", "Scroll Protocol"]
    correct_option_id: 0
    explanation: "Sliver Protocol. Подробнее тут: https://api.flutter.dev/flutter/rendering/RenderSliver-class.html"
    open_period: 20
  - question: "Выберете НЕВЕРНОЕ утверждение. В рамках верстки Flutter..."
    picture: ""
    options: ["Ограничения спускаются от родительских виджетов к потомкам", "Виджеты-потомки сами устанавливают свое местоположение", "Виджеты-потомки сами устанавливают свой желаемый размер", "Все утверждения верны"]
    correct_option_id: 1
    explanation: "Три правила отрисовки во Flutter: 1) Ограничения передаются от родителя к ребенку. 2) Родитель устанавливает положение ребенка. 3) Ребенок сам устанавливает свой желаемый размер."
    open_period: 20
  - question: "Какая асимптотическая сложность получения ближайшего InheritedWidget, например, через context.getInheritedWidgetOfExactType<T>()?"
    picture: ""
    options: ["O(1)", "O(log(n))", "O(n)", "O(nlog(n))"]
    correct_option_id: 0
    explanation: "Сложность получения Inherited Widget'a через контекст - O(1), так как при создании каждого нового Элемента, ему передается HashMap, содержащая все инхеритед виджеты находящиеся выше по дереву"
    open_period: 20
  - question: "Есть ли во Flutter возможность подключения 'нативных' экранов, написанных на Kotlin и Swift?"
    picture: ""
    options: ["Нету", "Есть, через FlutterToNativeViewAdapter", "Есть, через через механизм PlatformView"]
    correct_option_id: 2
    explanation: "Для этих целей существует PlatformView (AndroidView, AndroidViewSurface и UIKitView)"
    open_period: 20
